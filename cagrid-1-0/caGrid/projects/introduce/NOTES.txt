To Do:
(DONE) Make sure that skeleton names entered in the GUI are acceptable.
	i.e. No Service in the name (fixed 12/7/05)
		 No non-acceptable characters for java class names

(DONE) Enable service to back up old service skeleton before altering and then provide rollback capabilities.
	i.e. Enable "undo" in the gui.

(DONE) Map the ext/NStoPkg.mappings with those in the skeleton (right now they are copied into the skeleton's file)
	
Security configuration

Metadata and registration configuration

Make notes on how to add a new template.

Need to programatically be able to 
	-create service from a pre-defined service template
	-add/remove new metadata to the service
	
(DONE) Because we are now using axis to generate the class names we will not be able to use synctool to always find out which methods are different.  We will need a better method.
		-- we do not need to know them upfront because we dont need to analyze the signatures, only look at the method names.

Need to be able to not only use Axis for the classnames but also use the users classnames if they provide there own beans or api.

Need to fix the browse screen so that it can work with paths that have spaces in them.

Need to make sure that the id's used to created archives are good from date through time.

(DONE) moved the sync tools over to use beans instead of using DOM.  Much cleaner an easier to maintain.

FUTURE WORK PROPOSED:
	-Graphically and programatically add state variables to RP (3 weeks)
	-Create templates for services who wish to use GRAM (1 week)
	-Graphically and programatically wrap an existing java API(interface) into a service(4 weeks)
	-Look into multi-language binding support etc (1 week)
	-Add grid test cases to test created service deployment nightly (2 days)
	-Add Robot test cases to test the GUI nightly(4 days)
	-integrate with caDSR for interface design (2 weeks)

=======================================================
 METADATA STUFF
=======================================================
Metadata xmlfile:
----------
schematype AttGroup
populateFromFile (boolean)
register (boolean)
Qname of RP
(derive instance filename from QName?)

what to template:
=====
type goes into serviceRPs in wsdl
qname goes into registration.xml if registerType is true
if loadFromFile is true derived instance path goes into jndi config
if loadFromFile is true add getter/setter to MDconfig.java
make callback for non-file metadata


templating details:

ResourceConstants.java
----------
for each type (the QName is how the RP is identified... it doesn't have to be the schema QName as you can have several RPs for the same type(but we are gonna to use that for now)):
  public static final QName <upper case rp name>_MD_RP = new QName(<qname namespace>, <qname element name>);
Example:
  public static final QName COMMON_MD_RP = new QName("gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common", "CommonServiceMetadata");


BaseResource.java field definitions:
----------
for each type:
  private ResourceProperty <rp name>RP;
  private <bean class name> <rp name>MD;
Example:
  private ResourceProperty commonRP;
  private CommonServiceMetadataType commonMD;


BaseResource.java initialize [public void initialize() throws Exception {]:
----------
for each type:
  this.<rp name>RP = new SimpleResourceProperty(ResourceConstants.<upper case rp name>_MD_RP);
  this.<rp name>RP.add(this.<rp name>MD);
  this.propSet.add(this.<rp name>RP);
Example:
  this.commonRP = new SimpleResourceProperty(ResourceConstants.COMMON_MD_RP);
  this.commonRP.add(this.commonMD);
  this.propSet.add(this.commonRP);


BaseResource.java make a method for loading each type from a file (for those that should be synced from file):
----------
for each type, define a method to populate the bean:
	private void load<type element name>FromFile() {
		try {
			this.<rp name>MD = (<bean class name>) CommonTools.deserializeDocument(getConfiguration().get<type element name>File(),
				<bean class name>.class);
		} catch (Exception e) {
			logger.error("ERROR: problem populating metadata from file: " + e.getMessage(), e);
		}
	}
Example:
	private void loadCommonServiceMetadataFromFile() {
		try {
			this.commonMD = (CommonServiceMetadataType) CommonTools.deserializeDocument(getConfiguration().getCommonMetadataFile(),
				CommonServiceMetadataType.class);
		} catch (Exception e) {
			logger.error("ERROR: problem populating metadata from file: " + e.getMessage(), e);
		}
	}

BaseResource.java add the population method to the populateMetadata method:
----------
for each type:
	private void populateMetadata() {
		load<type element name>FromFile(); 
	}
Example:
	private void populateMetadata() {
		loadCommonServiceMetadataFromFile(); 
	}

	
MetadataConfigutation.java add a feild definition for the file location:
----------
for each type being loaded from a file:
	private String <type element name>File;
Example:
	private String commonServiceMetadataFile;


MetadataConfigutation.java add a getter and setter for file location:
----------
for each type being loaded from a file:
	public String get<type element name>File() {
		return <type element name>File;
	}
	public void set<type element name>File(String <type element name>File) {
		this.<type element name>File = <type element name>File;
	}
Example:
	public String getCommonServiceMetadataFile() {
		return commonServiceMetadataFile;
	}
	public void setCommonServiceMetadataFile(String commonServiceMetadataFile) {
		this.commonServiceMetadataFile = commonServiceMetadataFile;
	}


registration.xml add types to register:
----------
for each type that should be registered (if register is true), add the ns prefix to GetMultipleResourcePropertiesPollType element and QName to ResourcePropertyNames element:
      <agg:GetMultipleResourcePropertiesPollType  ...
        xmlns:<rp qname namespace prefix>="<rp qname namespace>" ... >   
        <agg:ResourcePropertyNames><rp qname namespace prefix>:<rp qname name></agg:ResourcePropertyNames>
Example:
      <agg:GetMultipleResourcePropertiesPollType  ...
        xmlns:com="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common" ... >   
        <agg:ResourcePropertyNames>com:CommonServiceMetadata</agg:ResourcePropertyNames>


serivce.wsdl add qnames into serviceRP definition in the schema section
----------
for each type, add a ref to the element def qname, and import statement to the local schema:
        <schema ...
            xmlns:<qname namespace prefix>="<rp qname namespace>"
            ... >
            <import namespace="<rp type namespace>"
                schemaLocation="<rp schema location>"/>
            <element name="<%=serviceName%>ResourceProperties">
                <complexType>
                    <sequence>
                        <element ref="<qname namespace prefix>:<qname name>"/>
                    </sequence>
                </complexType>
Example:
        <schema ...
            xmlns:com="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common"
            ... >
            <import namespace="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common"
                schemaLocation="../cagrid/types/common/CommonServiceMetadata.xsd"/>
            <element name="<%=serviceName%>ResourceProperties">
                <complexType>
                    <sequence>
                        <element ref="com:CommonServiceMetadata"/>
                    </sequence>
                </complexType>

=======================================================