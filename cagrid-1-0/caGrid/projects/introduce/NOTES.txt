To Do:

Make a method, save, add code to client and impl, modify name of input parameter, save, build error when trying to remove method and then unable to delete directory.

if introduce.jar and the like is removed from the service and expected to be run from elsewhere, introduce will need to check that it supports the version of 
introduce.xml that the service uses.  We need to either have a "version" attribute in the document, or use the xmlns to decide the version.
(probably should add a version attribute as the behavior could change without the dcoument structure changing).

When introduce adds new methods it shouldn't add a "return null;" it should add the following (even if its a void method):
	throw new RemoteException("Not yet implemented");

is client-config.wsdd really needed in the root dir?  can't you just add GLOBUS_LOCATION to your classpath

How about changing this "@created by caGrid toolkit version 0.5"

MUST FIX THE WHITESPACE SENSTIVE CODE FINDER!!!

when you download a schema that has dependencies, the dependant schemas are not added to the namespace to package mappings... you need to parse every schema, looking for imports, and make sure each imported schema has a mapping

(DONE) need to NOT generate stubs for schemas that the user specifies the class to use... this is important as it will/could generate classes with exact same name and cause the service to break
-- still need to handle imported schemas, but so do the rest of the code (package mappings, etc)

(DONE) Click Modifiy Service, Click Save, Click Cancel or No, Save Progress comes up.

(DONE) Create service needs to check that the directory they select is empty.  If not, should prompt and ask if it is ok to delete the dir and recreate it.

(DONE)Click Modify Service Click Cancel, Null pointer.

(DONE) Make sure that skeleton names entered in the GUI are acceptable.
	i.e. No Service in the name (fixed 12/7/05)
		 No non-acceptable characters for java class names

(DONE) Enable service to back up old service skeleton before altering and then provide rollback capabilities.
	i.e. Enable "undo" in the gui.

(DONE) Map the ext/NStoPkg.mappings with those in the skeleton (right now they are copied into the skeleton's file)

(DONE) namespace to package mappings should be jettemplated at sync time

Security configuration (STEVE)

(DONE) Metadata and registration configuration

need a way to generate XSD and beanmappers for existing object models that want to use default de/serialization


================================================================================
Need to verify we can achieve literal mapping between caDSR definition, XML serialization, and generated bean model
(we need to create a simple one of these, and add it to the specification document)

Example Model:
org.foo.A
  -org.foo.B b;
  -org.foo.C c;

XML (with appropriate namespaces of course):
<A>
  <B/>
  <C/>
<A>

Java Model:
org.foo
  -A {B b; C c;}
  -B
  -C
================================================================================




(*STARTED*  need to add more)Add gui testing (requires a HEAD to run)

Make notes on how to add a new template.

Need to validate the model before we begin to do code gen
	-- will reduce bugs and bug checking
	-- validate that the package names and classnames are being set correctly
	--VALIDATION:
		-unique method names
		-unique metadata qnames
		-run schema validation?
		-others?
	
(DONE)Need to support "MODIFIED" methods.
	-- support for changing of 
		-- output type
		-- number and type of parameters
		-- number and types of faults
	
	
GMEMetadataConfigurationComponent needs to set proper view on viewing an existing one from "modify"

(DONE) add packageName as a seperate parameter so that we can handle the funny mappings that we will use for caDSR->GME schemas.....

(DONE) Because we are now using axis to generate the class names we will not be able to use synctool to always find out which methods are different.  We will need a better method.
		-- we do not need to know them upfront because we dont need to analyze the signatures, only look at the method names.

(DONE using sync tools to populate empty classnames) Need to be able to not only use Axis for the classnames but also use the users classnames if they provide there own beans or api.

(DONE Need to fix the browse screen so that it can work with paths that have spaces in them.

(DONE) Need to make sure that the id's used to created archives are good from date through time.

(DONE) Need to pull the namespace to mappings code out of the gui and into the template.

Need to add more complex tests to the system test for adding complex methods with faults etc.

(DONE) moved the sync tools over to use beans instead of using DOM.  Much cleaner an easier to maintain.

FUTURE WORK PROPOSED:
	-Graphically and programatically add state variables to RP (3 weeks)
	-Create templates for services who wish to use GRAM (1 week)
	-Graphically and programatically wrap an existing java API(interface) into a service(4 weeks)
	-Look into multi-language binding support etc (1 week)
	-Add grid test cases to test created service deployment nightly (2 days)
	-Add Robot test cases to test the GUI nightly(4 days)
	-integrate with caDSR for interface design (2 weeks)

=======================================================
 METADATA STUFF
=======================================================
Metadata xmlfile:
----------
schematype AttGroup
populateFromFile (boolean)
register (boolean)
Qname of RP
(derive instance filename from QName?)

what to template:
=====
type goes into serviceRPs in wsdl
qname goes into registration.xml if registerType is true
if loadFromFile is true derived instance path goes into jndi config
if loadFromFile is true add getter/setter to MDconfig.java
make callback for non-file metadata


templating details:

(DONE) ResourceConstants.java
----------
for each type (the QName is how the RP is identified... it doesn't have to be the schema QName as you can have several RPs for the same type(but we are gonna to use that for now)):
  public static final QName <upper case rp name>_MD_RP = new QName(<qname namespace>, <qname element name>);
Example:
  public static final QName COMMON_MD_RP = new QName("gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common", "CommonServiceMetadata");


(DONE) BaseResource.java field definitions:
----------
for each type:
  private ResourceProperty <rp name>RP;
  private <bean class name> <rp name>MD;
Example:
  private ResourceProperty commonRP;
  private CommonServiceMetadataType commonMD;


(DONE) BaseResource.java initialize [public void initialize() throws Exception {]:
----------
for each type:
  this.<rp name>RP = new SimpleResourceProperty(ResourceConstants.<upper case rp name>_MD_RP);
  this.<rp name>RP.add(this.<rp name>MD);
  this.propSet.add(this.<rp name>RP);
Example:
  this.commonRP = new SimpleResourceProperty(ResourceConstants.COMMON_MD_RP);
  this.commonRP.add(this.commonMD);
  this.propSet.add(this.commonRP);


(DONE) BaseResource.java make a method for loading each type from a file (for those that should be synced from file):
----------
for each type, define a method to populate the bean:
	private void load<rp name>FromFile() {
		try {
			this.<rp name>MD = (<bean class name>) CommonTools.deserializeDocument(getConfiguration().get<rp name>File(),
				<bean class name>.class);
		} catch (Exception e) {
			logger.error("ERROR: problem populating metadata from file: " + e.getMessage(), e);
		}
	}
Example:
	private void loadCommonServiceMetadataFromFile() {
		try {
			this.commonMD = (CommonServiceMetadataType) CommonTools.deserializeDocument(getConfiguration().getCommonMetadataFile(),
				CommonServiceMetadataType.class);
		} catch (Exception e) {
			logger.error("ERROR: problem populating metadata from file: " + e.getMessage(), e);
		}
	}

(DONE) BaseResource.java add the population method to the populateMetadata method:
----------
for each type:
	private void populateMetadata() {
		load<rp name>FromFile(); 
	}
Example:
	private void populateMetadata() {
		loadCommonServiceMetadataFromFile(); 
	}

	
(DONE) MetadataConfigutation.java add a feild definition for the file location:
----------
for each type being loaded from a file:
	private String <rp name>File;
Example:
	private String commonServiceMetadataFile;


(DONE) MetadataConfigutation.java add a getter and setter for file location:
----------
for each type being loaded from a file:
	public String get<rp name>File() {
		return <rp name>File;
	}
	public void set<rp name>File(String <rp name>File) {
		this.<rp name>File = <rp name>File;
	}
Example:
	public String getCommonServiceMetadataFile() {
		return commonServiceMetadataFile;
	}
	public void setCommonServiceMetadataFile(String commonServiceMetadataFile) {
		this.commonServiceMetadataFile = commonServiceMetadataFile;
	}


(DONE) registration.xml add types to register:
----------
for each type that should be registered (if register is true), add the ns prefix to GetMultipleResourcePropertiesPollType element and QName to ResourcePropertyNames element:
      <agg:GetMultipleResourcePropertiesPollType ... >   
        <agg:ResourcePropertyNames xmlns:<rp qname namespace prefix>="<rp qname namespace>"><rp qname namespace prefix>:<rp qname name></agg:ResourcePropertyNames>
Example:
      <agg:GetMultipleResourcePropertiesPollType ... >   
        <agg:ResourcePropertyNames xmlns:com="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common">com:CommonServiceMetadata</agg:ResourcePropertyNames>


(DONE) serivce.wsdl add qnames into serviceRP definition in the schema section
----------
for each type, add a ref to the element def qname, and import statement to the local schema:
        <schema ...
            xmlns:<qname namespace prefix>="<rp qname namespace>"
            ... >
            <import namespace="<rp type namespace>"
                schemaLocation="<rp schema location>"/>
            <element name="<%=serviceName%>ResourceProperties">
                <complexType>
                    <sequence>
                        <element ref="<qname namespace prefix>:<qname name>"/>
                    </sequence>
                </complexType>
Example:
        <schema ...
            xmlns:com="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common"
            ... >
            <import namespace="gme://caGrid.caBIG/1.0/gov.nih.nci.cagrid.metadata.common"
                schemaLocation="../cagrid/types/common/CommonServiceMetadata.xsd"/>
            <element name="<%=serviceName%>ResourceProperties">
                <complexType>
                    <sequence>
                        <element ref="com:CommonServiceMetadata"/>
                    </sequence>
                </complexType>

(DONE)jndi-config.xml need to add a path to the file 
----------
for each that should be synced from file:
				<parameter>
					<name><rp name>File</name>
					<!-- Set this to the full path of the common metadata extract -->
					<value>FULL-ETC-PATH/<rp name>.xml</value>
				</parameter>

Example:
				<parameter>
					<name>commonMetadataFile</name>
					<!-- Set this to the full path of the common metadata extract -->
					<value>FULL-ETC-PATH/commonMetadata.xml</value>
				</parameter>



=======================================================


=======================================================
 SECURITY STUFF
=======================================================


1) Client Side Authorization

	A) Add Support for Identity Authorization
	B) Add Support for Custom Authorization
	C) Add Input for host and Identity Authorization

2) Server Side Authorization, Add Support for the following authorization mechanisms

	A) None
	B) Self
	C) GridMap
	D) Identity Authorization
	E) Host Authorization
	F) SAML Callout Authorization
		
3) Add Client side support for delegation

4) Add Service Credential Support

5) Add Service Run As Support

6) Add Service Side Support for Rejecting Limited Proxies.


